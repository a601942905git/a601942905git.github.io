{"title":"一文读懂Redis持久化机制","uid":"077c9e1306e9e7f4038efb1171146e9a","slug":"一文读懂Redis持久化机制","date":"2022-12-18T07:32:00.000Z","updated":"2022-12-18T07:34:42.028Z","comments":true,"path":"api/articles/一文读懂Redis持久化机制.json","keywords":null,"cover":[],"content":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h2><p><code>redis</code>作为内存数据库，最常见的使用场景就是当<code>缓存</code>用。浏览器访问后端应用，后端应用先访问<code>redis</code>，如果<code>redis</code>中有数据，直接返回；否则就去查询数据库。</p>\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20220512191500.png\"></p>\n<p>如你所知，<code>redis</code>作为内存数据库，数据存放在内存中，如果宕机，会导致数据全部丢失。数据丢失，来自浏览器的所有请求都会去查询数据库，一方面会给数据库带来巨大压力；另一方面由于这些请求需要访问数据库，相比访问<code>redis</code>会导致响应时间变长。</p>\n<p>假如<code>redis</code>在宕机恢复后数据不丢失，就可以避免给数据库造成巨大压力和导致响应时间变长问题。要想实现数据恢复，可以使用<code>redis</code>持久化方案<code>aof</code>和<code>rdb</code></p>\n<h2 id=\"2-AOF\"><a href=\"#2-AOF\" class=\"headerlink\" title=\"2.AOF\"></a>2.AOF</h2><h3 id=\"2-1-官方说明\"><a href=\"#2-1-官方说明\" class=\"headerlink\" title=\"2.1 官方说明\"></a>2.1 官方说明</h3><p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20220512202200.png\"></p>\n<p>1.<code>redis</code>官方认为<code>RDB</code>快照方式可以满足大多数应用，因此默认情况下只会开启<code>RDB</code>快照方式进行持久化。</p>\n<p>2.<code>RDB</code>快照方式在服务停电时会造成数分钟写丢失，为了保证数据少丢，可以选择使用<code>AOF</code>持久化</p>\n<p>3.<code>AOF</code>和<code>RDB</code>可以同时开启，如果<code>AOF</code>功能开启，<code>Redis</code>在启动时会加载<code>AOF</code>文件</p>\n<h3 id=\"2-2-开启AOF功能\"><a href=\"#2-2-开启AOF功能\" class=\"headerlink\" title=\"2.2 开启AOF功能\"></a>2.2 开启AOF功能</h3><p>将<code>appendonly</code>后面的<code>no</code>改成<code>yes</code>即可开启<code>AOF</code>功能</p>\n<h3 id=\"2-3-验证AOF功能\"><a href=\"#2-3-验证AOF功能\" class=\"headerlink\" title=\"2.3 验证AOF功能\"></a>2.3 验证AOF功能</h3><p>通过客户端执行<code>set k1 v1</code>，在<code>AOF</code>文件中可以看到如下内容</p>\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20220512204600.png\"></p>\n<h3 id=\"2-3-写入时机\"><a href=\"#2-3-写入时机\" class=\"headerlink\" title=\"2.3 写入时机\"></a>2.3 写入时机</h3><p><code>redis</code>为了避免检查写命令开销，选择了先<code>写命令，再记日志</code></p>\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/2022-512205500.png\"></p>\n<h3 id=\"2-3-写入策略\"><a href=\"#2-3-写入策略\" class=\"headerlink\" title=\"2.3 写入策略\"></a>2.3 写入策略</h3><p><code>redis</code>记日志是在主线程中完成，为了平衡<code>高可靠性</code>与<code>高性能</code>，提供了<code>三种</code>写入策略</p>\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20220513101100.png\"></p>\n<table>\n<thead>\n<tr>\n<th>写入策略</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>no(操作系统写回)</td>\n<td>性能最高</td>\n<td>数据丢的最多</td>\n</tr>\n<tr>\n<td>always(同步写回)</td>\n<td>性能最差</td>\n<td>可以保证几乎不丢数据</td>\n</tr>\n<tr>\n<td>everysec(每秒写回)</td>\n<td>性能适中</td>\n<td>最多丢1s数据</td>\n</tr>\n</tbody></table>\n<p><code>redis</code>默认情况下选择<code>每秒写回策略</code>，丢失1s数据一般还是比较能接受；如果选择<code>操作系统写回</code>说明能够接受大量数据丢失，此时可以考虑只使用<code>RDB</code>,不开启<code>AOF</code></p>\n<h3 id=\"2-4-aof文件过大怎么办\"><a href=\"#2-4-aof文件过大怎么办\" class=\"headerlink\" title=\"2.4 aof文件过大怎么办\"></a>2.4 aof文件过大怎么办</h3><p>当<code>redis</code>开启<code>aof</code>持久化功能后，<code>客户端</code>的写命令会被持续记录在<code>aof</code>日志文件中，时间越长，<code>aof</code>日志文件就会越大，那么文件过大会有什么影响呢？</p>\n<ul>\n<li>文件系统对文件大小有限制，无法保存过大文件</li>\n<li>如果文件过大，之后再往里面追加日志记录，效率也会变低</li>\n<li><code>redis</code>宕机，重启过程中会执行<code>aof</code>文件中的记录，如果文件过大，会导致重启时间过长，服务长时间不可用</li>\n</ul>\n<p>为了避免这些影响，<code>aof</code>文件在达到一定大小后就需要对其重写</p>\n<h3 id=\"2-5-重写依据\"><a href=\"#2-5-重写依据\" class=\"headerlink\" title=\"2.5 重写依据\"></a>2.5 重写依据</h3><p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20220515204400.png\"></p>\n<p><code>aof</code>文件大小达到<code>64M</code>并且当前大小相比上一次重写后<code>aof</code>文件的大小增长100%就会触发重写操作</p>\n<h3 id=\"2-4-aof重写过程\"><a href=\"#2-4-aof重写过程\" class=\"headerlink\" title=\"2.4 aof重写过程\"></a>2.4 aof重写过程</h3><p><code>aof</code>重写可以选择在主线程中执行，主线程读取<code>redis</code>中的数据以命令的方式记录在重写<code>aof</code>文件中，读取完成后，用重写<code>aof</code>文件替换旧<code>aof</code>文件即可完成重写。方案简单易用，问题同样也很明显，那就是在重写完成之前无法对外提供服务。此时你大概会很好奇为什么<code>redis</code>在提供重写能力的同时还能响应客户端的请求，它是如何实现的呢？答案就是<code>fork()</code>，我们来看看<code>fork()</code>究竟干了什么</p>\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20220515212500.png\"></p>\n<p><code>aof</code>文件达到重写要求后，<code>redis</code>会通过<code>fork()</code>系统调用创建出一个<code>子进程</code>(用来执行重写操作)，<code>子进程</code>会拷贝<code>主进程</code>的虚拟地址空间，这样<code>主进程</code>和<code>子进程</code>就可以共享内存中的数据。</p>\n<p><code>子进程</code>重写过程中只需要读取内存中的数据以命令方式追加到重写<code>aof</code>文件中即可，重写过程中产生的新的写命令会被主进程记录在<code>重写aof缓冲中</code>，内存中的数据重写完成后再将<code>重写aof缓冲</code>中的命令追加到<code>重写aof</code>文件中，最后用<code>重写aof文件</code>替换<code>原aof</code>文件就完成了整个重写操作。</p>\n<p>为了引出下一个知识点，先带你分析一种场景：重新过程中<code>redis</code>中有这样一条数据<code>k1 =1</code>,客户端执行了<code>incr k1</code>命令后<code>k1</code>就等于2，<code>主进程</code>会在<code>重新aof缓冲</code>中记录<code>incr k1</code>命令，由于<code>k1</code>在内存中的数据等于2，<code>子线程</code>重写追加到文件中的命令应该是<code>set k1 = 2</code>，等重写完内存中的数据后，再追加<code>重写aof缓冲</code>中的<code>incr k1</code>命令，就会导致<code>k1</code>实际的值变成3而不是2，产生数据不一致性问题。</p>\n<p>如何避免在重写的过程中产生数据不一致性的问题呢？答案就是：写时复制（copy on write（COW）），主进程有写操作发生时，需要将内存中的数据复制一份再进行修改，而不是在原来的数据上进行修改，主进程虚拟地址指向复制后的物理地址；子进程还是指向原来的物理地址，<code>aof</code>重写操作完成后<code>k1</code>的值是2而不是3，与预期结果一致。</p>\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20220517100200.png\"></p>\n<h2 id=\"3-RDB\"><a href=\"#3-RDB\" class=\"headerlink\" title=\"3.RDB\"></a>3.RDB</h2><h3 id=\"3-1-aof持久化存在的问题\"><a href=\"#3-1-aof持久化存在的问题\" class=\"headerlink\" title=\"3.1 aof持久化存在的问题\"></a>3.1 aof持久化存在的问题</h3><p>由于<code>aof</code>日志文件中记录的是操作命令，在进行数据恢复时，需要将日志文件中的命令逐条执行，一旦日志文件过大，就会导致<code>redis</code>数据恢复时间变长。那么有没有一种方式既可以实现内存数据持久化，又能快速恢复内存数据的解决方案呢？</p>\n<p><code>rdb(redis database)</code>：存放的是内存中的数据而非执行的命令，因此在满足内存数据持久化的同时又达到能快速恢复数据的目的。</p>\n<h3 id=\"3-2-rdb流程\"><a href=\"#3-2-rdb流程\" class=\"headerlink\" title=\"3.2 rdb流程\"></a>3.2 rdb流程</h3><p>同<code>aof</code>日志文件重写一样，执行<code>rdb</code>操作的时候<code>主进程</code>也会<code>fork</code>出一个<code>子进程</code>，用于将内存的数据写入到文件中。此时你可能会有疑问，如果<code>子进程</code>在持久过的过程中，内存中的数据发生变化了怎么办？</p>\n<p>事实上，<code>子进程</code>持久化的是内存中的快照数据，那么什么是<code>快照数据</code>呢？</p>\n<p><code>快照数据</code>就是某一时刻内存中的数据，<code>子进程</code>在持久化的过程中，如果有写入操作，会通过<code>cow(copy on wirte)</code>技术来保证<code>快照数据</code>不被修改。</p>\n<h3 id=\"3-3-rdb写入频率\"><a href=\"#3-3-rdb写入频率\" class=\"headerlink\" title=\"3.3 rdb写入频率\"></a>3.3 rdb写入频率</h3><p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221218145200.png\"></p>\n<p>根据配置文件说明，使用者可以自定义<code>rdb</code>写入频率，但是设置多少合适呢？频率太高，会造成磁盘写入压力过大，上次一次写入任务还未执行完成下一次写入任务又开启了，从而进入恶性循环；频率太低，会造成数据丢失过多的问题发生，因此写入频率的设置是一个不太好衡量的操作。</p>\n<h3 id=\"3-4-aof-rdb\"><a href=\"#3-4-aof-rdb\" class=\"headerlink\" title=\"3.4 aof + rdb\"></a>3.4 aof + rdb</h3><p>既然<code>rdb</code>写入频率不太好去衡量，那么我们可以结合<code>aof</code>来解决<code>rbd</code>周期之间数据丢失的问题。使用<code>rdb + aof</code>结合方式既可以满足内存数据的快速恢复，又可以实现内存数据的持久化。</p>\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221218151100.png\"></p>\n","feature":true,"text":"1.前言redis作为内存数据库，最常见的使用场景就是当缓存用。浏览器访问后端应用，后端应用先访问redis，如果redis中有数据，直接返回；否则就去查询数据库。 如你所知，redis作为内存数据库，数据存放在内存中，如果宕机，会导致数据全部丢失。数据丢失，来自浏览器的所有请求...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"redis","slug":"redis","count":3,"path":"api/categories/redis.json"}],"tags":[{"name":"redis","slug":"redis","count":2,"path":"api/tags/redis.json"},{"name":"aof","slug":"aof","count":2,"path":"api/tags/aof.json"},{"name":"rdb","slug":"rdb","count":2,"path":"api/tags/rdb.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">1.前言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-AOF\"><span class=\"toc-text\">2.AOF</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E5%AE%98%E6%96%B9%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">2.1 官方说明</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E5%BC%80%E5%90%AFAOF%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">2.2 开启AOF功能</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E9%AA%8C%E8%AF%81AOF%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">2.3 验证AOF功能</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E5%86%99%E5%85%A5%E6%97%B6%E6%9C%BA\"><span class=\"toc-text\">2.3 写入时机</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E5%86%99%E5%85%A5%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">2.3 写入策略</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-aof%E6%96%87%E4%BB%B6%E8%BF%87%E5%A4%A7%E6%80%8E%E4%B9%88%E5%8A%9E\"><span class=\"toc-text\">2.4 aof文件过大怎么办</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-5-%E9%87%8D%E5%86%99%E4%BE%9D%E6%8D%AE\"><span class=\"toc-text\">2.5 重写依据</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-aof%E9%87%8D%E5%86%99%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">2.4 aof重写过程</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-RDB\"><span class=\"toc-text\">3.RDB</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-aof%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">3.1 aof持久化存在的问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-rdb%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">3.2 rdb流程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-rdb%E5%86%99%E5%85%A5%E9%A2%91%E7%8E%87\"><span class=\"toc-text\">3.3 rdb写入频率</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-aof-rdb\"><span class=\"toc-text\">3.4 aof + rdb</span></a></li></ol></li></ol>","author":{"name":"黑白搬砖工","slug":"blog-author","avatar":"https://wolf-heart.oss-cn-beijing.aliyuncs.com/lg_22641_1606122876_5fbb7d7c432a1.jpeg","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/a601942905git","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/483440845930343","customs":{}}},"mapped":true,"prev_post":{"title":"Redis单机、主从、哨兵、集群演进之路","uid":"c301ef2215df3326fec1a274349ffccd","slug":"Redis单机、主从、哨兵、集群演进之路","date":"2023-01-04T01:49:00.000Z","updated":"2023-01-04T01:49:54.152Z","comments":true,"path":"api/articles/Redis单机、主从、哨兵、集群演进之路.json","keywords":null,"cover":[],"text":"1.前言1.1 单机时代刚接触redis的时候，为了能快速学习和了解这门技术，我们通常会在自己的电脑上部署一个redis服务，以此来开启redis学习之路 1.2 主从时代随着对redis的进一步深入，很快就会发现这门技术在很多场景下都能得到应用，比如：并发场景下对共享资源的控制...","link":"","photos":[],"count_time":{"symbolsCount":"8.3k","symbolsTime":"8 mins."},"categories":[{"name":"redis","slug":"redis","count":3,"path":"api/categories/redis.json"}],"tags":[{"name":"redis","slug":"redis","count":2,"path":"api/tags/redis.json"},{"name":"aof","slug":"aof","count":2,"path":"api/tags/aof.json"},{"name":"rdb","slug":"rdb","count":2,"path":"api/tags/rdb.json"}],"author":{"name":"黑白搬砖工","slug":"blog-author","avatar":"https://wolf-heart.oss-cn-beijing.aliyuncs.com/lg_22641_1606122876_5fbb7d7c432a1.jpeg","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/a601942905git","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/483440845930343","customs":{}}},"feature":true},"next_post":{"title":"动态伸缩你的服务","uid":"a74d032dc9bf8ca9d012adc342b4fd84","slug":"动态伸缩你的服务","date":"2022-12-10T13:57:00.000Z","updated":"2022-12-10T14:01:06.650Z","comments":true,"path":"api/articles/动态伸缩你的服务.json","keywords":null,"cover":[],"text":"1.前言如你所知，服务的常规部署方式如下： 对外暴露的服务都会在前面部署nginx用于提供反向代理和负载均衡能力 下面会快速部署一套类似的服务，分析其存在的问题并给出相应解决方案 2.应用相关2.1 启动服务使用boot-cloud-openfeign-provider启动3个服...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"微服务","slug":"微服务","count":3,"path":"api/categories/微服务.json"}],"tags":[{"name":"consul","slug":"consul","count":1,"path":"api/tags/consul.json"},{"name":"nginx","slug":"nginx","count":1,"path":"api/tags/nginx.json"},{"name":"consul-template","slug":"consul-template","count":1,"path":"api/tags/consul-template.json"}],"author":{"name":"黑白搬砖工","slug":"blog-author","avatar":"https://wolf-heart.oss-cn-beijing.aliyuncs.com/lg_22641_1606122876_5fbb7d7c432a1.jpeg","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/a601942905git","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/483440845930343","customs":{}}},"feature":true}}