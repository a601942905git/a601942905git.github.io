{"title":"带你看懂redis IO模型","uid":"5ce0c663a19d8e8ee699635ec101be20","slug":"IO模型","date":"2022-12-11T05:49:28.000Z","updated":"2022-12-11T05:53:54.916Z","comments":true,"path":"api/articles/IO模型.json","keywords":null,"cover":[],"content":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h2><p>如你所知，高性能web服务器<code>Nginx</code>选择使用<code>IO多路复用</code>技术处理客户端请求，高性能内存数据库<code>Redis</code>同样也选择使用<code>IO多路复用</code>技术处理客户端请求，这足以说明<code>IO多路复用</code>是非常优秀的IO模型，毕竟<code>人以类聚、物以群分</code>。</p>\n<p>接下来会从<code>传统阻塞IO模型说</code>起，聊到<code>传统非阻塞IO模型</code>，再到<code>IO多路复用</code></p>\n<h2 id=\"2-IO模型\"><a href=\"#2-IO模型\" class=\"headerlink\" title=\"2. IO模型\"></a>2. IO模型</h2><h3 id=\"2-1-传统阻塞IO模型\"><a href=\"#2-1-传统阻塞IO模型\" class=\"headerlink\" title=\"2.1 传统阻塞IO模型\"></a>2.1 传统阻塞IO模型</h3><p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/1651144275489.jpg\"></p>\n<p><code>传统阻塞IO模型</code>中，当客户端与服务器端建立连接创建<code>socket</code>后，服务端需要从<code>socket</code>中读取数据，如果<code>socket</code>数据不可读，就会阻塞当前线程，又由于是<code>单线程</code>，就会导致服务端无法对外提供任何服务</p>\n<h3 id=\"2-2-传统非阻塞IO模型\"><a href=\"#2-2-传统非阻塞IO模型\" class=\"headerlink\" title=\"2.2 传统非阻塞IO模型\"></a>2.2 传统非阻塞IO模型</h3><p>通过对<code>传统阻塞IO模型</code>进行分析后，可得知问题的关键在<code>单线程</code>上，知道问题所在，对应解决方案也就有了，那就是针对每个<code>client</code>创建一个线程进行<code>socket</code>数据读取</p>\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/1651146663041.jpg\"></p>\n<p>通过<code>多线程</code>解决了<code>单线程</code>阻塞导致服务不可用的问题，随之而来也带了一个新的问题，那就是线程过多会造成资源浪费(每个线程拥有1M栈空间)、上下文切换问题</p>\n<h3 id=\"2-3-多路复用\"><a href=\"#2-3-多路复用\" class=\"headerlink\" title=\"2.3 多路复用\"></a>2.3 多路复用</h3><p><code>单线程</code>和<code>多线程</code>都有对应的问题存在，那么还有其它更好的解决方案嘛？方案当然是有的，那就是<code>IO多路复用</code>。<code>IO多路复用</code>的实现有<code>select()</code>、<code>poll()</code>、<code>epoll()</code>,分别来看一下</p>\n<h4 id=\"2-3-1-术语介绍\"><a href=\"#2-3-1-术语介绍\" class=\"headerlink\" title=\"2.3.1 术语介绍\"></a>2.3.1 术语介绍</h4><p>文件描述符：客户端与服务端建立的<code>socket</code>连接称作一个<code>文件描述符（File Descriptor 以下简称 FD）</code></p>\n<h4 id=\"2-3-2-select\"><a href=\"#2-3-2-select\" class=\"headerlink\" title=\"2.3.2 select()\"></a>2.3.2 select()</h4><h5 id=\"2-3-2-1-描述\"><a href=\"#2-3-2-1-描述\" class=\"headerlink\" title=\"2.3.2.1 描述\"></a>2.3.2.1 描述</h5><p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/1651148038872.jpg\"></p>\n<p>通过<code>select()</code>描述可以得知该函数允许应用程序同时监听多个<code>fd</code>，在<code>fd</code>可读可写之前会一直阻塞，同时还有一个很关键的点，那就是<code>select()</code>同时监听的<code>文件描述符</code>数量不能大于1024</p>\n<h5 id=\"2-3-2-2-返回值\"><a href=\"#2-3-2-2-返回值\" class=\"headerlink\" title=\"2.3.2.2 返回值\"></a>2.3.2.2 返回值</h5><p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/1651148511191.jpg\"></p>\n<p><code>select()</code>调用成功后会返回就绪<code>fd</code>个数</p>\n<h5 id=\"2-3-2-3-流程\"><a href=\"#2-3-2-3-流程\" class=\"headerlink\" title=\"2.3.2.3 流程\"></a>2.3.2.3 流程</h5><p><code>应用程序</code>调用<code>select()</code>函数将<code>fd</code>传给<code>内核空间</code></p>\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/1651148752932.jpg\"></p>\n<p>内核空间会对<code>fd</code>进行循环遍历，当有<code>fd</code>变得<code>就绪</code>后，<code>应用程序</code>的<code>select()</code>调用会返回就绪<code>fd</code>个数，此时<code>应用程序</code>再通过循环遍历方式读取就绪<code>fd</code>数据</p>\n<h5 id=\"2-3-2-4-存在的问题\"><a href=\"#2-3-2-4-存在的问题\" class=\"headerlink\" title=\"2.3.2.4 存在的问题\"></a>2.3.2.4 存在的问题</h5><ul>\n<li><code>内核</code>不知道<code>fd</code>何时<code>就绪</code>，只能通过循环遍历的方式得知，会造成<code>CPU</code>资源浪费</li>\n<li><code>内核</code> 只会返回就绪<code>fd</code>的个数，<code>应用程序</code>并不知道具体哪个<code>fd</code>是就绪状态，只能再次循环系统调用才可得知，会造成无效系统调用</li>\n<li>同时监听<code>文件描述符</code>数不能超过<code>1024</code></li>\n</ul>\n<h4 id=\"2-3-2-epoll\"><a href=\"#2-3-2-epoll\" class=\"headerlink\" title=\"2.3.2 epoll\"></a>2.3.2 epoll</h4><h5 id=\"2-3-3-1-描述\"><a href=\"#2-3-3-1-描述\" class=\"headerlink\" title=\"2.3.3.1 描述\"></a>2.3.3.1 描述</h5><p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/1651150772232.jpg\"></p>\n<p><code>epoll</code>API核心概念就是<code>epoll</code> instance，<code>epoll instance</code>是一个内核数据结构。从<code>用户空间</code>角度来看，<code>epoll instance</code>是一个包含<code>进程注册的fd列表</code>和<code>就绪fd列表</code>的容器</p>\n<p><code>epoll</code>提供了3个系统调用用于<code>创建</code>和<code>管理</code>epoll实例</p>\n<ul>\n<li><code>epoll_create</code>：创建一个epoll实例，并返回一个<code>fd</code></li>\n<li><code>epoll_ctl</code>：对<code>fd</code>进行增、删、改</li>\n<li><code>epoll_wait</code>：阻塞等待IO事件</li>\n</ul>\n<h5 id=\"2-3-3-2-流程\"><a href=\"#2-3-3-2-流程\" class=\"headerlink\" title=\"2.3.3.2 流程\"></a>2.3.3.2 流程</h5><p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/1651200905790.jpg\"></p>\n<p>先通过<code>epoll_create</code>创建一个<code>epoll instance</code>，再通过<code>epoll_ctl</code>往注册列表中添加<code>fd</code>并监听对应事件(比如读事件、写事件)，最后通过<code>epoll_wait</code>阻塞等待，直到就绪列表中有<code>fd</code>为止，期间如果某个<code>fd</code>就绪，会从注册列表中移动到就绪列表中，<code>epoll_wait</code>返回<code>就绪fd</code>个数</p>\n<p>通过流程可以看到：</p>\n<ul>\n<li><p>应用程序每次都是增量往注册列表中添加<code>fd</code>，而不像<code>select</code>那样每次都传所有<code>fd</code></p>\n</li>\n<li><p>内核空间通过事件驱动方式得知<code>fd</code>就绪，而不像<code>select</code>那样需要循环遍历</p>\n</li>\n<li><p><code>epoll_wait</code>返回的后，应用程序知道具体哪一个<code>fd</code>就绪，而不像<code>select</code>那样循环遍历所有<code>fd</code>才知道哪些处于就绪状态</p>\n</li>\n</ul>\n<h5 id=\"2-3-3-3-示例分析\"><a href=\"#2-3-3-3-示例分析\" class=\"headerlink\" title=\"2.3.3.3 示例分析\"></a>2.3.3.3 示例分析</h5><p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_abd88863-5c17-453b-9953-aba745216c9b.png\"></p>\n<h2 id=\"3-查看redis的IO多路复用实现\"><a href=\"#3-查看redis的IO多路复用实现\" class=\"headerlink\" title=\"3. 查看redis的IO多路复用实现\"></a>3. 查看redis的IO多路复用实现</h2><h3 id=\"3-1-追踪redis\"><a href=\"#3-1-追踪redis\" class=\"headerlink\" title=\"3.1 追踪redis\"></a>3.1 追踪redis</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">strace</span> <span class=\"token parameter variable\">-ff</span> <span class=\"token parameter variable\">-o</span> ./redis.out redis-6.2.6/src/redis-server /opt/redis/redis-6.2.6/redis.conf<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"3-2-查看追踪文件\"><a href=\"#3-2-查看追踪文件\" class=\"headerlink\" title=\"3.2 查看追踪文件\"></a>3.2 查看追踪文件</h3><p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/1650693377577.jpg\"></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">vi</span> redis.out.5444<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/1650693732879.jpg\"></p>\n<p>可以看到<code>redis</code>通过<code>epoll</code>实现了<code>IO多路复用</code></p>\n","text":"1.前言如你所知，高性能web服务器Nginx选择使用IO多路复用技术处理客户端请求，高性能内存数据库Redis同样也选择使用IO多路复用技术处理客户端请求，这足以说明IO多路复用是非常优秀的IO模型，毕竟人以类聚、物以群分。 接下来会从传统阻塞IO模型说起，聊到传统非阻塞IO模...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"redis","slug":"redis","count":2,"path":"api/categories/redis.json"}],"tags":[{"name":"多路复用","slug":"多路复用","count":1,"path":"api/tags/多路复用.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">1.前言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-IO%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">2. IO模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E4%BC%A0%E7%BB%9F%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">2.1 传统阻塞IO模型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E4%BC%A0%E7%BB%9F%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">2.2 传统非阻塞IO模型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8\"><span class=\"toc-text\">2.3 多路复用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-1-%E6%9C%AF%E8%AF%AD%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">2.3.1 术语介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-2-select\"><span class=\"toc-text\">2.3.2 select()</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-3-2-1-%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">2.3.2.1 描述</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-3-2-2-%E8%BF%94%E5%9B%9E%E5%80%BC\"><span class=\"toc-text\">2.3.2.2 返回值</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-3-2-3-%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">2.3.2.3 流程</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-3-2-4-%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">2.3.2.4 存在的问题</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-2-epoll\"><span class=\"toc-text\">2.3.2 epoll</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-3-3-1-%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">2.3.3.1 描述</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-3-3-2-%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">2.3.3.2 流程</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-3-3-3-%E7%A4%BA%E4%BE%8B%E5%88%86%E6%9E%90\"><span class=\"toc-text\">2.3.3.3 示例分析</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E6%9F%A5%E7%9C%8Bredis%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">3. 查看redis的IO多路复用实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-%E8%BF%BD%E8%B8%AAredis\"><span class=\"toc-text\">3.1 追踪redis</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-%E6%9F%A5%E7%9C%8B%E8%BF%BD%E8%B8%AA%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">3.2 查看追踪文件</span></a></li></ol></li></ol>","author":{"name":"黑白搬砖工","slug":"blog-author","avatar":"https://wolf-heart.oss-cn-beijing.aliyuncs.com/lg_22641_1606122876_5fbb7d7c432a1.jpeg","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/a601942905git","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/483440845930343","customs":{}}},"mapped":true,"prev_post":{"title":"kafka存储","uid":"9f635fa5cf662529fd1247abdd3830ea","slug":"kafka存储","date":"2022-12-11T05:50:10.000Z","updated":"2022-12-11T05:50:11.338Z","comments":true,"path":"api/articles/kafka存储.json","keywords":null,"cover":[],"text":"1.前言系统仅仅拥有高并发、高可用往往是不够的，在此基础上还需要具备高可靠性。那么什么是高可靠性呢？高可靠性就是系统在宕机恢复后数据不丢失，仍然可以保证业务的正常运行。 作为业务系统的开发人员，提到数据持久化，基于本能反应首选想到的一定是数据库。kafka作为消息中间件，会选择什...","link":"","photos":[],"count_time":{"symbolsCount":"9.1k","symbolsTime":"8 mins."},"categories":[{"name":"消息中间件","slug":"消息中间件","count":6,"path":"api/categories/消息中间件.json"}],"tags":[{"name":"kafka","slug":"kafka","count":4,"path":"api/tags/kafka.json"}],"author":{"name":"黑白搬砖工","slug":"blog-author","avatar":"https://wolf-heart.oss-cn-beijing.aliyuncs.com/lg_22641_1606122876_5fbb7d7c432a1.jpeg","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/a601942905git","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/483440845930343","customs":{}}}},"next_post":{"title":"消息积压你作何处理？","uid":"f8c1d4f8bf32cb91acc7b2a551ae4194","slug":"kafka消费异常会如何处理？","date":"2022-12-11T05:48:32.000Z","updated":"2022-12-11T05:51:46.951Z","comments":true,"path":"api/articles/kafka消费异常会如何处理？.json","keywords":null,"cover":null,"text":"1.前言当我们使用@KafkaListener注解声明一个消费者时，该消费者就会轮询去拉取对应分区消息记录，消费消息记录，正如你所知道的那样，正常场景下会执行ack操作，提交offset到kafka服务器。但是异常场景下会如何执行，不知你是否也了解？在了解之前，先一起来看下异常处...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"消息中间件","slug":"消息中间件","count":6,"path":"api/categories/消息中间件.json"}],"tags":[{"name":"kafka","slug":"kafka","count":4,"path":"api/tags/kafka.json"}],"author":{"name":"黑白搬砖工","slug":"blog-author","avatar":"https://wolf-heart.oss-cn-beijing.aliyuncs.com/lg_22641_1606122876_5fbb7d7c432a1.jpeg","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/a601942905git","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/483440845930343","customs":{}}}}}