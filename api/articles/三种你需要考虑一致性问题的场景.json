{"title":"三种你需要考虑的一致性问题的场景","uid":"24fad9e0b20684c1cf6b335f2dccd634","slug":"三种你需要考虑一致性问题的场景","date":"2022-12-10T13:57:00.000Z","updated":"2022-12-11T12:20:01.881Z","comments":true,"path":"api/articles/三种你需要考虑一致性问题的场景.json","keywords":null,"cover":[],"content":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h2><p>分布式系统开发过程中往往会涉及到很多需要保证数据一致性问题的场景，比如<code>接收mq消息</code>、<code>接收http请求</code>、<code>内部业务处理。</code>如果你还不了解这些场景或者不知道如何处理，请继续往下阅读。</p>\n<h2 id=\"2-接收mq消息\"><a href=\"#2-接收mq消息\" class=\"headerlink\" title=\"2.接收mq消息\"></a>2.接收mq消息</h2><p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/mq/1648360473464.jpg\"></p>\n<p>接收mq消息场景在分布式系统开发过程中想必是一种比较常见的场景，具体过程就是，外围系统推送mq消息到开发系统，开发系统接收消息后进行业务逻辑处理。从表面上看是一个十分简单的流程，但是如果涉及数据一致性问题，就不那么简单了。</p>\n<p>为什么说不那么简单呢？先来看看以下场景：</p>\n<h3 id=\"2-1-先ack消息再处理业务\"><a href=\"#2-1-先ack消息再处理业务\" class=\"headerlink\" title=\"2.1 先ack消息再处理业务\"></a>2.1 先ack消息再处理业务</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token function\">ack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 处理业务逻辑</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>先ack消息再处理业务在<code>理想</code>场景下是不会有什么问题，看到这里你可能会有疑惑，没有问题那不就得了，还需要考虑什么呢？请注意这种没问题是建立在<code>理想</code>的前提下，如果业务处理过程中调用外部接口异常或者数据库宕机，就会导致消息丢失，进而出现数据不一致性的问题。</p>\n<h3 id=\"2-2-先处理业务再ack消息\"><a href=\"#2-2-先处理业务再ack消息\" class=\"headerlink\" title=\"2.2 先处理业务再ack消息\"></a>2.2 先处理业务再ack消息</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token comment\">// 处理业务逻辑</span>\n<span class=\"token function\">ack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>既然先ack消息再处理业务这条路走不通，那么就先处理业务再ack消息总没问题了吧。是的，即便业务处理失败消息没有被ack，消息还会被重新消费，不会出现数据不一致性问题。但是这会涉及到另外一个问题，那就是幂等性问题，幂等问题处理不好，还是会引起数据不一致性问题。</p>\n<p>其实先处理业务再ack消息还会引起另一个问题，如果业务系统有bug会造成消息一直无法被ack，进而会导致消息处理进入死循环。</p>\n<p>这样也不行，那样也不行，就没有解决方案了？当然不是，方案还是有的，且听我慢慢跟你说</p>\n<h3 id=\"2-3-结合消息ack机制-数据库-定时任务方案一\"><a href=\"#2-3-结合消息ack机制-数据库-定时任务方案一\" class=\"headerlink\" title=\"2.3  结合消息ack机制 + 数据库 + 定时任务方案一\"></a>2.3  结合消息ack机制 + 数据库 + 定时任务方案一</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">try</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// 根据消息唯一编号查询该消息是否已处理过，如果没有处理过，进行处理业务；如果处理过，则说明都不做</span>\n    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n       <span class=\"token comment\">// 将处理异常的消息插入数据库中</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token function\">ack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">unack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>大体思路就是，根据消息唯一编号判断消息是否被处理过，如果未被处理过，就对消息进行处理，处理成功则对消息进行ack；处理失败则将消息存入数据库中。如果存入数据库这一步操作还是失败，那么就对消息进行unack操作，将消息重新投递到消息服务器中，进而重新消费，直到数据库恢复为止。针对处理失败入库的消息，可以通过定时任务重试处理。</p>\n<p>该方案不仅可以解决<code>2.2</code>中的幂等性问题，还可以解决业务出现bug进而导致消息处理进入死循环的问题(限制重试次数)。但是该方案还是会存在一个跟本文无关的问题，那就是<code>消息积压</code>问题。</p>\n<h3 id=\"2-4-结合消息ack机制-数据库-定时任务方案二\"><a href=\"#2-4-结合消息ack机制-数据库-定时任务方案二\" class=\"headerlink\" title=\"2.4 结合消息ack机制 + 数据库 + 定时任务方案二\"></a>2.4 结合消息ack机制 + 数据库 + 定时任务方案二</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">try</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 根据消息唯一编号查询该消息是否存在，不存在则直接插入数据库中，存在则不进行处理</span>\n    <span class=\"token function\">ack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 异步处理业务逻辑</span>\n<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">unack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><code>2.4</code>与<code>2.3</code>优缺点对比</p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2.3</td>\n<td>只在业务处理失败将消息插入数据库中，消息数量不会太多</td>\n<td>消息处理慢会导致消息积压</td>\n</tr>\n<tr>\n<td>2.4</td>\n<td>消息异步处理，不会导致消息积压</td>\n<td>所有消息都存储数据库，消息数量可能会很多</td>\n</tr>\n</tbody></table>\n<p>关于这两种方案可以根据实际情况进行自由选择，消息积压问题处理也可以参考：<a href=\"https://juejin.cn/post/7044084323418406948\">消息积压你作何处理？</a></p>\n<h2 id=\"3-接收http请求\"><a href=\"#3-接收http请求\" class=\"headerlink\" title=\"3. 接收http请求\"></a>3. 接收http请求</h2><p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/mq/1648364094714.jpg\"></p>\n<p>看到这个图你可能会想这不就是一个很简单的流程嘛，开发系统接收请求、处理请求、响应结果就可以了。如你所想，确实很简单，但是如果你的开发系统业务处理失败，就会导致外围系统进行重试，直到重试次数用完，开发系统还未恢复正常，那么此次的外围请求数据就会丢失，从而引起数据不一致性问题。</p>\n<p>认真分析一下该场景，你会发现造成数据不一致性问题的关键在于开发系统的业务处理。如果开发系统能在正确接收外围系统请求后立刻进行响应，那么就可以解决该问题。</p>\n<p>我们只需要在接收http请求后，将请求内容写入数据库，写入成功进行异步处理并返回成功；写入失败返回失败，通过外围重试来保证数据可以正常写入数据库。处理失败的内容可以结合定时任务对请求进行重试。</p>\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/mq/1648365628683.jpg\"></p>\n<h2 id=\"4-内部业务处理\"><a href=\"#4-内部业务处理\" class=\"headerlink\" title=\"4.内部业务处理\"></a>4.内部业务处理</h2><p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/mq/1648365958211.jpg\"></p>\n<p>开发系统某些业务在处理成功后往往需要通知某些外围系统并且还不能因为外围系统故障从而导致当前业务无法正确处理，既然不能影响当前业务，可以采用异步的方式进行处理，异步处理就会存在当前业务处理成功，通知外围失败的问题，进而引起数据不一致性问题。</p>\n<p>那有没有办法可以保证业务处理成功的同时，对外围的通知也一定成功呢？</p>\n<p>我们可以采用本地事务的方案，把通知给外围的数据放在当前业务的事务中插入到数据库，异步通知外围系统，处理失败的数据再结合定时任务进行重试。</p>\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/mq/1648367058446.jpg\"></p>\n<h2 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5.总结\"></a>5.总结</h2><p>从文中我们可以看到一致性问题的解决方案都逃不开数据库 + 重试，因此在解决一致性问题的时候可以多往这方面考虑。</p>\n","text":"1.前言分布式系统开发过程中往往会涉及到很多需要保证数据一致性问题的场景，比如接收mq消息、接收http请求、内部业务处理。如果你还不了解这些场景或者不知道如何处理，请继续往下阅读。 2.接收mq消息 接收mq消息场景在分布式系统开发过程中想必是一种比较常见的场景，具体过程就是，...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"微服务","slug":"微服务","count":3,"path":"api/categories/微服务.json"}],"tags":[{"name":"一致性","slug":"一致性","count":1,"path":"api/tags/一致性.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">1.前言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E6%8E%A5%E6%94%B6mq%E6%B6%88%E6%81%AF\"><span class=\"toc-text\">2.接收mq消息</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E5%85%88ack%E6%B6%88%E6%81%AF%E5%86%8D%E5%A4%84%E7%90%86%E4%B8%9A%E5%8A%A1\"><span class=\"toc-text\">2.1 先ack消息再处理业务</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E5%85%88%E5%A4%84%E7%90%86%E4%B8%9A%E5%8A%A1%E5%86%8Dack%E6%B6%88%E6%81%AF\"><span class=\"toc-text\">2.2 先处理业务再ack消息</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E7%BB%93%E5%90%88%E6%B6%88%E6%81%AFack%E6%9C%BA%E5%88%B6-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%96%B9%E6%A1%88%E4%B8%80\"><span class=\"toc-text\">2.3  结合消息ack机制 + 数据库 + 定时任务方案一</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-%E7%BB%93%E5%90%88%E6%B6%88%E6%81%AFack%E6%9C%BA%E5%88%B6-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%96%B9%E6%A1%88%E4%BA%8C\"><span class=\"toc-text\">2.4 结合消息ack机制 + 数据库 + 定时任务方案二</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E6%8E%A5%E6%94%B6http%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">3. 接收http请求</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%86%85%E9%83%A8%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86\"><span class=\"toc-text\">4.内部业务处理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">5.总结</span></a></li></ol>","author":{"name":"黑白搬砖工","slug":"blog-author","avatar":"https://wolf-heart.oss-cn-beijing.aliyuncs.com/lg_22641_1606122876_5fbb7d7c432a1.jpeg","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/a601942905git","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/483440845930343","customs":{}}},"mapped":true,"prev_post":{"title":"系统重启你的应用会怎么样？","uid":"a7366034e22a497a711893a0546ee23b","slug":"系统重启你的应用会怎么样？","date":"2022-12-10T13:58:00.000Z","updated":"2022-12-11T05:42:48.291Z","comments":true,"path":"api/articles/系统重启你的应用会怎么样？.json","keywords":null,"cover":[],"text":"1.前言近日就系统重启引发了一些思考，在系统重启过程中，正在进行的请求会如何被处理？正在消费的消息会不会丢失？异步执行的任务会不会被中断？既然存在这些问题，那我们的应用程序是不是就不能重启？但是，我们的应用程序随着版本迭代也在不断重启为什么这些问题没有出现呢？还是应用做了额外处理...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"微服务","slug":"微服务","count":3,"path":"api/categories/微服务.json"}],"tags":[{"name":"优雅停机","slug":"优雅停机","count":1,"path":"api/tags/优雅停机.json"}],"author":{"name":"黑白搬砖工","slug":"blog-author","avatar":"https://wolf-heart.oss-cn-beijing.aliyuncs.com/lg_22641_1606122876_5fbb7d7c432a1.jpeg","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/a601942905git","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/483440845930343","customs":{}}}},"next_post":{}}