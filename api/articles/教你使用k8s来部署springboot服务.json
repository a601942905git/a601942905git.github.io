{"title":"教你使用k8s来部署springboot服务","uid":"49acd5a35f32f11bb2cfd91bb3c1f221","slug":"教你使用k8s来部署springboot服务","date":"2023-03-17T14:03:00.000Z","updated":"2023-03-17T14:04:16.276Z","comments":true,"path":"api/articles/教你使用k8s来部署springboot服务.json","keywords":null,"cover":[],"content":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h2><p>在看到此文章之前，想必你已经知道如何启动一个<code>spring boot</code>应用，知道如何通过<code>docker</code>运行你的<code>spring boot</code>服务。</p>\n<p>你可能会有这样得疑问，已经了解如上部署方式，是否还有必须去了解如何通过<code>k8s</code>部署<code>spring boot</code>应用？</p>\n<p>如果你有这样的疑问，那么请继续往下看。</p>\n<h2 id=\"2-创建SpringBoot应用\"><a href=\"#2-创建SpringBoot应用\" class=\"headerlink\" title=\"2.创建SpringBoot应用\"></a>2.创建SpringBoot应用</h2><p>在介绍<code>k8s</code>部署<code>spring boot</code>应用之前，我们需要创建一个<code>spring boot</code>应用。</p>\n<h3 id=\"2-1-编写pom-xml\"><a href=\"#2-1-编写pom-xml\" class=\"headerlink\" title=\"2.1 编写pom.xml\"></a>2.1 编写pom.xml</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n​\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;parent&gt;\n        &lt;artifactId&gt;boot-example-advance&lt;&#x2F;artifactId&gt;\n        &lt;groupId&gt;com.boot.example&lt;&#x2F;groupId&gt;\n        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;&#x2F;parent&gt;\n​\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n    &lt;artifactId&gt;boot-example-docker&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n​\n    &lt;name&gt;boot-example-docker&lt;&#x2F;name&gt;\n    &lt;url&gt;http:&#x2F;&#x2F;www.example.com&lt;&#x2F;url&gt;\n​\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n​\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;\n                &lt;executions&gt;\n                    &lt;execution&gt;\n                        &lt;goals&gt;\n                            &lt;goal&gt;repackage&lt;&#x2F;goal&gt;\n                            &lt;goal&gt;build-info&lt;&#x2F;goal&gt;\n                        &lt;&#x2F;goals&gt;\n                    &lt;&#x2F;execution&gt;\n                &lt;&#x2F;executions&gt;\n            &lt;&#x2F;plugin&gt;\n        &lt;&#x2F;plugins&gt;\n    &lt;&#x2F;build&gt;\n&lt;&#x2F;project&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"2-2-编写程序\"><a href=\"#2-2-编写程序\" class=\"headerlink\" title=\"2.2 编写程序\"></a>2.2 编写程序</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">@SpringBootApplication\n@RestController\npublic class DockerApplication &#123;\n​\n​\n    @GetMapping(&quot;&#x2F;&quot;)\n    public String home() &#123;\n        try &#123;\n            return &quot;Hello Docker World：&quot; + InetAddress.getLocalHost().getHostAddress();\n        &#125; catch (UnknownHostException e) &#123;\n            return &quot;Hello Docker World&quot;;\n        &#125;\n    &#125;\n​\n    public static void main(String[] args) &#123;\n        SpringApplication.run(DockerApplication.class, args);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"2-3-应用打包\"><a href=\"#2-3-应用打包\" class=\"headerlink\" title=\"2.3 应用打包\"></a>2.3 应用打包</h3><p>通过<code>mvn clean package -X</code>命令对该应用进行打包，执行完命令后可以看到<code>target</code>目录下生成了一个<code>xxx.jar</code>的包</p>\n<h2 id=\"3-构建镜像\"><a href=\"#3-构建镜像\" class=\"headerlink\" title=\"3.构建镜像\"></a>3.构建镜像</h2><p>有了应用包，需要编写<code>Dockerfile</code>文件将应用包构建成一个<code>镜像</code></p>\n<h2 id=\"3-1-编写Dockerfile\"><a href=\"#3-1-编写Dockerfile\" class=\"headerlink\" title=\"3.1 编写Dockerfile\"></a>3.1 编写Dockerfile</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">FROM openjdk:8-jdk-alpine\nARG JAR_FILE&#x3D;target&#x2F;*.jar\nCOPY $&#123;JAR_FILE&#125; app.jar\nENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;&#x2F;app.jar&quot;]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"3-2-构建镜像\"><a href=\"#3-2-构建镜像\" class=\"headerlink\" title=\"3.2 构建镜像\"></a>3.2 构建镜像</h3><p>有了<code>jar</code>包和<code>Dockerfile</code>文件就可以使用<code>docker build -t a601942905/app .</code>命令来构建镜像</p>\n<h4 id=\"3-2-1-查看镜像是否构建成功\"><a href=\"#3-2-1-查看镜像是否构建成功\" class=\"headerlink\" title=\"3.2.1 查看镜像是否构建成功\"></a>3.2.1 查看镜像是否构建成功</h4><p>构建完<code>镜像</code>后则可以通过<code>docker images</code>命令来查看是否存在刚才构建的镜像，存在则说明<code>镜像</code>构建成功</p>\n<h4 id=\"3-2-2-验证镜像的正确性\"><a href=\"#3-2-2-验证镜像的正确性\" class=\"headerlink\" title=\"3.2.2 验证镜像的正确性\"></a>3.2.2 验证镜像的正确性</h4><p>如果本地存在构建的镜像，可以通过<code>docker run --name myapp -p 8080:8080 -d a601942905/app</code>命令将<code>镜像</code>启动成<code>容器</code></p>\n<p>使用<code>docker ps</code>命令查看容器是否正常启动，如果正常启动，可以通过<code>curl localhost:8080</code>访问服务接口， 正常响应，则说明<code>镜像</code>可以正常使用</p>\n<h2 id=\"3-3-推送镜像\"><a href=\"#3-3-推送镜像\" class=\"headerlink\" title=\"3.3 推送镜像\"></a>3.3 推送镜像</h2><p>为了让<code>k8s</code>能够拉取到镜像，需要将构建好的本地<code>镜像</code>通过<code>docker push a601942905/app</code>命令推送到远程仓库</p>\n<h2 id=\"4-k8s\"><a href=\"#4-k8s\" class=\"headerlink\" title=\"4.k8s\"></a>4.k8s</h2><p>有了<code>镜像</code>，就可以使用<code>k8s</code>来部署服务</p>\n<h3 id=\"4-1-创建deployment\"><a href=\"#4-1-创建deployment\" class=\"headerlink\" title=\"4.1 创建deployment\"></a>4.1 创建deployment</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">kubectl create deployment myapp --image&#x3D;a601942905&#x2F;app<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"4-2-创建service\"><a href=\"#4-2-创建service\" class=\"headerlink\" title=\"4.2 创建service\"></a>4.2 创建service</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">kubectl expose deployment myapp --type&#x3D;NodePort --port&#x3D;8080<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"4-3-访问服务\"><a href=\"#4-3-访问服务\" class=\"headerlink\" title=\"4.3 访问服务\"></a>4.3 访问服务</h3><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aadce3a4778e42b1a052f844874e6a6f~tplv-k3u1fbpfcp-zoom-1.image\"> 在浏览器中输入ip + 端口即可访问对应的服务</p>\n<h3 id=\"4-4-服务扩容\"><a href=\"#4-4-服务扩容\" class=\"headerlink\" title=\"4.4 服务扩容\"></a>4.4 服务扩容</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">kubectl scale --replicas&#x3D;5 deployment&#x2F;myapp<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac6401d159b94a579c2c6e130dc3214a~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p><code>扩容</code>之后可以看到同时存在<code>5</code>个myapp <code>pod</code>服务，这在实际场景中是非常有用的。当我们的服务压力过大、负载过高时，就可以通过该方式实现服务扩容，使得服务可以提供更高的并发能力，渡过高峰期。</p>\n<h3 id=\"4-5-服务缩容\"><a href=\"#4-5-服务缩容\" class=\"headerlink\" title=\"4.5 服务缩容\"></a>4.5 服务缩容</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">kubectl scale --replicas&#x3D;3 deployment&#x2F;myapp<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/856920007b6e47078bc46ef7752bd784~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>过了业务高峰期，之前扩容的服务就会存在冗余，造成资源浪费。可以通过如上方式实现服务缩容，从而达到服务降本的目的</p>\n<h3 id=\"4-6-服务自愈\"><a href=\"#4-6-服务自愈\" class=\"headerlink\" title=\"4.6 服务自愈\"></a>4.6 服务自愈</h3><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf2426dfbd5f4bb1ac5798514f3213be~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>服务在运行的过程中，由于某些原因会导致<code>pod</code>故障，从而造成对外提供服务的数量减少。在业务高峰时期，这种故障的产生可能会拖垮整个服务，从而导致无法对外提供服务。使用<code>k8s</code>完全不用担心这种故障的发生，当<code>pod</code>服务故障后，<code>k8s</code>会重新启动一个新<code>pod</code>服务</p>\n<h3 id=\"4-7-服务滚动更新\"><a href=\"#4-7-服务滚动更新\" class=\"headerlink\" title=\"4.7 服务滚动更新\"></a>4.7 服务滚动更新</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">kubectl set image deploy&#x2F;myapp app&#x3D;a601942905&#x2F;app:latest<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b8b98cb5c444e3fa1e202abe80b3d88~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>服务发布后，如果发布服务的配置存在问题，导致服务无法启动，此时整个应用都无法对外提供服务。<code>滚动更新</code>会先启动一个新服务，当新服务启动后再关掉一个旧服务，这样即便服务由于配置问题无法启动，也不会影响线上服务，从而提高服务的<code>slo</code></p>\n<h3 id=\"4-8-版本回退\"><a href=\"#4-8-版本回退\" class=\"headerlink\" title=\"4.8 版本回退\"></a>4.8 版本回退</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">kubectl rollout undo deploy&#x2F;myapp<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92c794117a224a499704a378a46f4c9d~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>服务发版不可以避免的一个问题：本地、测试环境测的好好的，一到线上就报错。遇到这种情况，我们的第一反应就是<code>版本回退</code>，从而让服务恢复到正常状态</p>\n<h2 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5.总结\"></a>5.总结</h2><p>看到这里，想必你已经知道为什么要了解<code>k8s</code>来部署服务。因为<code>k8s</code>可以轻松实现<code>服务扩容</code>、<code>服务缩容</code>、<code>服务自愈</code>、<code>服务滚动更新</code>和<code>服务版本回退</code></p>\n","feature":true,"text":"1.前言在看到此文章之前，想必你已经知道如何启动一个spring boot应用，知道如何通过docker运行你的spring boot服务。 你可能会有这样得疑问，已经了解如上部署方式，是否还有必须去了解如何通过k8s部署spring boot应用？ 如果你有这样的疑问，那么请继...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"云原生","slug":"云原生","count":1,"path":"api/categories/云原生.json"}],"tags":[{"name":"k8s","slug":"k8s","count":1,"path":"api/tags/k8s.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">1.前言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%88%9B%E5%BB%BASpringBoot%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">2.创建SpringBoot应用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E7%BC%96%E5%86%99pom-xml\"><span class=\"toc-text\">2.1 编写pom.xml</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E7%BC%96%E5%86%99%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">2.2 编写程序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E5%BA%94%E7%94%A8%E6%89%93%E5%8C%85\"><span class=\"toc-text\">2.3 应用打包</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F\"><span class=\"toc-text\">3.构建镜像</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-%E7%BC%96%E5%86%99Dockerfile\"><span class=\"toc-text\">3.1 编写Dockerfile</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F\"><span class=\"toc-text\">3.2 构建镜像</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-1-%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F%E6%98%AF%E5%90%A6%E6%9E%84%E5%BB%BA%E6%88%90%E5%8A%9F\"><span class=\"toc-text\">3.2.1 查看镜像是否构建成功</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-2-%E9%AA%8C%E8%AF%81%E9%95%9C%E5%83%8F%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7\"><span class=\"toc-text\">3.2.2 验证镜像的正确性</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-%E6%8E%A8%E9%80%81%E9%95%9C%E5%83%8F\"><span class=\"toc-text\">3.3 推送镜像</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-k8s\"><span class=\"toc-text\">4.k8s</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-%E5%88%9B%E5%BB%BAdeployment\"><span class=\"toc-text\">4.1 创建deployment</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-%E5%88%9B%E5%BB%BAservice\"><span class=\"toc-text\">4.2 创建service</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1\"><span class=\"toc-text\">4.3 访问服务</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-%E6%9C%8D%E5%8A%A1%E6%89%A9%E5%AE%B9\"><span class=\"toc-text\">4.4 服务扩容</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-5-%E6%9C%8D%E5%8A%A1%E7%BC%A9%E5%AE%B9\"><span class=\"toc-text\">4.5 服务缩容</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-6-%E6%9C%8D%E5%8A%A1%E8%87%AA%E6%84%88\"><span class=\"toc-text\">4.6 服务自愈</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-7-%E6%9C%8D%E5%8A%A1%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0\"><span class=\"toc-text\">4.7 服务滚动更新</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-8-%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80\"><span class=\"toc-text\">4.8 版本回退</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">5.总结</span></a></li></ol>","author":{"name":"黑白搬砖工","slug":"blog-author","avatar":"https://wolf-heart.oss-cn-beijing.aliyuncs.com/lg_22641_1606122876_5fbb7d7c432a1.jpeg","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/a601942905git","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/483440845930343","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"docker入门笔记","uid":"ef54352044e70ece8fc193948e3b79c1","slug":"docker入门笔记","date":"2023-03-05T12:35:00.000Z","updated":"2023-03-05T12:35:45.586Z","comments":true,"path":"api/articles/docker入门笔记.json","keywords":null,"cover":[],"text":"1.docker概述Docker是一个开源的容器化平台，它可以将应用程序及其所有依赖项打包成一个独立的可移植的容器。Docker容器提供了一个隔离的环境，使得应用程序可以在不同的操作系统和平台上运行，同时保证了应用程序的一致性和可移植性。 1.1 容器与虚拟机的区别1.1.1 容...","link":"","photos":[],"count_time":{"symbolsCount":"7.7k","symbolsTime":"7 mins."},"categories":[{"name":"容器","slug":"容器","count":1,"path":"api/categories/容器.json"}],"tags":[{"name":"docker","slug":"docker","count":1,"path":"api/tags/docker.json"}],"author":{"name":"黑白搬砖工","slug":"blog-author","avatar":"https://wolf-heart.oss-cn-beijing.aliyuncs.com/lg_22641_1606122876_5fbb7d7c432a1.jpeg","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/a601942905git","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/483440845930343","customs":{}}},"feature":true}}