{"title":"Redis单机、主从、哨兵、集群演进之路","uid":"c301ef2215df3326fec1a274349ffccd","slug":"Redis单机、主从、哨兵、集群演进之路","date":"2023-01-04T01:49:00.000Z","updated":"2023-03-05T12:42:10.609Z","comments":true,"path":"api/articles/Redis单机、主从、哨兵、集群演进之路.json","keywords":null,"cover":[],"content":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h2><h3 id=\"1-1-单机时代\"><a href=\"#1-1-单机时代\" class=\"headerlink\" title=\"1.1 单机时代\"></a>1.1 单机时代</h3><p>刚接触<code>redis</code>的时候，为了能快速学习和了解这门技术，我们通常会在自己的电脑上部署一个<code>redis</code>服务，以此来开启<code>redis</code>学习之路</p>\n<h3 id=\"1-2-主从时代\"><a href=\"#1-2-主从时代\" class=\"headerlink\" title=\"1.2 主从时代\"></a>1.2 主从时代</h3><p>随着对<code>redis</code>的进一步深入，很快就会发现这门技术在很多场景下都能得到应用，比如：并发场景下对共享资源的控制(分布式锁)、高并发场景下对系统的保护(限流)、高并发场景下对响应时间的要求(缓存)</p>\n<p>在生产环境使用<code>redis</code>服务是否能像当初我们学习时那样，仅仅部署一个单实例<code>redis</code>就可以呢？如果选择单实例部署，当该实例出现故障，使用<code>redis</code>的业务场景都会随之受影响。为了降低单实例故障带来的影响，通常会选择冗余的方式来保证服务的高可靠性，在<code>redis</code>中，我们称之为<code>主-从</code></p>\n<h3 id=\"1-3-哨兵时代\"><a href=\"#1-3-哨兵时代\" class=\"headerlink\" title=\"1.3 哨兵时代\"></a>1.3 哨兵时代</h3><p><code>redis</code>进行<code>主-从</code>部署后是不是就可以高枕无忧了呢？当然不是，你还需要时时刻刻监控<code>redis主</code>的健康状态，当其出现故障后能第一时间发现并能在<code>从库</code>中完成<code>选主</code>任务，否则同样会给相关业务带来影响。在<code>redis</code>中，我们通常会使用<code>哨兵</code>机制来帮我们完成<code>监控</code>、<code>选主</code>和<code>通知</code>操作，从而使我们的<code>redis</code>服务具备一定的高可靠性</p>\n<h3 id=\"1-4-集群分片时代\"><a href=\"#1-4-集群分片时代\" class=\"headerlink\" title=\"1.4 集群分片时代\"></a>1.4 集群分片时代</h3><p>随着业务的飞速发展，<code>redis</code>实例中存放的数据也越来越多，当需要存储<code>25G</code>以上的数据时，估计你会选择一台<code>32G</code>的机器进行部署这个看似简单的选择题却隐藏着很严重的问题：</p>\n<ul>\n<li><p><code>redis</code>中存放的数据越多，意味着宕机后的恢复时间也越长，从而导致服务长时间不可用</p>\n</li>\n<li><p>数据越多进行<code>rdb fork</code>操作的时候，阻塞<code>redis</code>主线程的时间也越长，从而导致服务响应慢</p>\n</li>\n</ul>\n<p>面对此类问题我们通常会基于<code>大而化小、分而治之</code>的思想进行解决，在<code>redis</code>中我们称之为<code>集群分片</code>技术</p>\n<p>开篇对单机、主从、哨兵、分片进行了简单介绍，下文将结合实战展开细说。</p>\n<h2 id=\"2-redis安装\"><a href=\"#2-redis安装\" class=\"headerlink\" title=\"2.redis安装\"></a>2.redis安装</h2><p><code>磨刀不误砍柴工</code>，在开始之前首先要保证我们的<code>redis</code>服务可以正常启动并能提供指令操作。</p>\n<h3 id=\"2-1下载安装包\"><a href=\"#2-1下载安装包\" class=\"headerlink\" title=\"2.1下载安装包\"></a>2.1下载安装包</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">wget</span> https://download.redis.io/redis-stable.tar.gz<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"2-2解压\"><a href=\"#2-2解压\" class=\"headerlink\" title=\"2.2解压\"></a>2.2解压</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">tar</span> <span class=\"token parameter variable\">-zxvf</span> redis-stable.tar.gz<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"2-3-编译\"><a href=\"#2-3-编译\" class=\"headerlink\" title=\"2.3 编译\"></a>2.3 编译</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">➜  redis-stable <span class=\"token function\">make</span> <span class=\"token operator\">&amp;</span> <span class=\"token function\">make</span> <span class=\"token function\">install</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"2-4-启动\"><a href=\"#2-4-启动\" class=\"headerlink\" title=\"2.4 启动\"></a>2.4 启动</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">redis-server<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"2-5-客户端连接测试\"><a href=\"#2-5-客户端连接测试\" class=\"headerlink\" title=\"2.5 客户端连接测试\"></a>2.5 客户端连接测试</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">redis-cli\n<span class=\"token number\">127.0</span>.0.1:637<span class=\"token operator\"><span class=\"token file-descriptor important\">9</span>></span> <span class=\"token builtin class-name\">set</span> name bobo\nOK\n<span class=\"token number\">127.0</span>.0.1:637<span class=\"token operator\"><span class=\"token file-descriptor important\">9</span>></span> get name\n<span class=\"token string\">\"bobo\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>完成服务的安装与测试，接下来就可以放手进行实战，实战的第一部分<code>主从</code></p>\n<h2 id=\"3-主从\"><a href=\"#3-主从\" class=\"headerlink\" title=\"3.主从\"></a>3.主从</h2><h3 id=\"3-1-部署图\"><a href=\"#3-1-部署图\" class=\"headerlink\" title=\"3.1 部署图\"></a>3.1 部署图</h3><p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221223154900.png\"></p>\n<p><code>主从</code>一共由3台机器组成，演示环境通过<code>端口号</code>进行区分</p>\n<h3 id=\"3-2-创建conf目录\"><a href=\"#3-2-创建conf目录\" class=\"headerlink\" title=\"3.2 创建conf目录\"></a>3.2 创建conf目录</h3><p><code>主从</code>由3个<code>redis</code>服务组成，每个<code>redis</code>服务对应的配置都不相同，因此需要创建<code>conf</code>文件夹用于存放配置文件</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">➜  redis-stable mkdir conf<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"3-3-生成redis配置文件\"><a href=\"#3-3-生成redis配置文件\" class=\"headerlink\" title=\"3.3 生成redis配置文件\"></a>3.3 生成redis配置文件</h3><p>默认情况下<code>redis.conf</code>配置文件会有很多注释说明，为了让配置文件看上去清晰明了，使用如下命令来去除配置文件中的注释以及空行</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">➜  redis-stable <span class=\"token function\">cat</span> redis.conf <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> <span class=\"token parameter variable\">-v</span> <span class=\"token string\">\"#\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> <span class=\"token parameter variable\">-v</span> <span class=\"token string\">\"^$\"</span> <span class=\"token operator\">></span> ./conf/redis-6379.conf<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"3-3-添加复制配置\"><a href=\"#3-3-添加复制配置\" class=\"headerlink\" title=\"3.3 添加复制配置\"></a>3.3 添加复制配置</h3><p><code>主从</code>方式，<code>从</code>需要知道应该从哪一个<code>主</code>进行数据复制，因此需要在<code>从</code>再配置文件中添加如下配置</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">replicaof <span class=\"token number\">127.0</span>.0.1 <span class=\"token number\">6380</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"3-4-拷贝redis配置文件\"><a href=\"#3-4-拷贝redis配置文件\" class=\"headerlink\" title=\"3.4 拷贝redis配置文件\"></a>3.4 拷贝redis配置文件</h3><p>之前也有过说明，演示环境通过<code>端口号</code>进行区分，因此配置文件中除了<code>端口号</code>以及<code>数据保存路径</code>不一样之外，其它的都一样，这里可以通过如下命令进行配置文件拷贝</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">➜  redis-stable <span class=\"token function\">sed</span> <span class=\"token string\">'s/6379/6380/g'</span> conf/redis-6379.conf <span class=\"token operator\">></span> conf/redis-6380.conf\n➜  redis-stable <span class=\"token function\">sed</span> <span class=\"token string\">'s/6379/6381/g'</span> conf/redis-6379.conf <span class=\"token operator\">></span> conf/redis-6381.conf<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"3-5-启动redis\"><a href=\"#3-5-启动redis\" class=\"headerlink\" title=\"3.5 启动redis\"></a>3.5 启动redis</h3><p><code>万事俱备，只欠东风</code>，准备工作完成之后，只需要逐个启动服务即可</p>\n<h4 id=\"3-5-1-启动主6379\"><a href=\"#3-5-1-启动主6379\" class=\"headerlink\" title=\"3.5.1 启动主6379\"></a>3.5.1 启动主6379</h4><p><code>从</code>在启动的时候需要和<code>主</code>建立连接，因此应先启动<code>主6379</code></p>\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221223155800.png\"></p>\n<p>通过日志文件可以了解到<code>主6379</code>在启动的过程中会去加载<code>rdb</code>文件用于数据恢复，并且从<code>rdb</code>文件中加载了一个<code>key</code></p>\n<h4 id=\"3-5-2-启动从6380\"><a href=\"#3-5-2-启动从6380\" class=\"headerlink\" title=\"3.5.2 启动从6380\"></a>3.5.2 启动从6380</h4><p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221223162800.png\"></p>\n<p><code>从6380</code>启动后，可以看到<code>主6379</code>的日志内容有所增加</p>\n<p><code>从6380</code>向<code>主6379</code>请求数据同步，由于是第一次会进行全量同步，<code>主6379 fork</code>进程生成<code>rdb</code>文件，然后将生成好的<code>rdb</code>文件传输给<code>6380</code></p>\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221223163300.png\"></p>\n<p><code>从6380</code>启动过程中会去连接<code>主6379</code>，接收<code>主6379</code>传过来的<code>rdb</code>文件，在清空旧数据之后加载<code>rdb</code>文件进行数据同步</p>\n<h4 id=\"3-5-3-启动从6381\"><a href=\"#3-5-3-启动从6381\" class=\"headerlink\" title=\"3.5.3 启动从6381\"></a>3.5.3 启动从6381</h4><p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221223164000.png\"></p>\n<p><code>从6381</code>启动和<code>从6380</code>启动是一样的流程，不再进行细说</p>\n<h4 id=\"3-5-4-重启6381\"><a href=\"#3-5-4-重启6381\" class=\"headerlink\" title=\"3.5.4 重启6381\"></a>3.5.4 重启6381</h4><p>到这里，你已经知道<code>从</code>在第一次连接<code>主</code>后会进行全量同步，估计也会好奇非第一次连接会如何进行同步。想知道结果，只需要重启其中一个<code>从</code>即可，这里选择重启<code>从6381</code></p>\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221223164500.png\"></p>\n<p>重启后，会发现<code>从6381</code>请求的是<code>增量</code>同步而非<code>全量</code>同步</p>\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221223164400.png\"></p>\n<p>通过<code>主6379</code>的日志可以看到其接受了<code>从6381</code>增量同步的请求，并从<code>backlog</code>偏移量183开始发送了245字节的数据</p>\n<p>这里可以猜想一下，<code>主6379</code>若想知道应该增量同步哪些数据给<code>从6381</code>，那么它一定得知道<code>从6381</code>上一次同步到哪里，因此重启再次连接的时候，<code>从6381</code>应该会将上一次同步到哪了的信息发给了<code>主6379</code></p>\n<p>关于数据同步部分，可以得出不知道从哪开始同步就选择<code>全量同步</code>，知道从哪开始同步就选择<code>增量同步</code>的结论</p>\n<h3 id=\"3-6-主从如何保证数据一致性？\"><a href=\"#3-6-主从如何保证数据一致性？\" class=\"headerlink\" title=\"3.6 主从如何保证数据一致性？\"></a>3.6 主从如何保证数据一致性？</h3><p>前面提到过，<code>主6379</code>在接到从的全量同步请求后会生成<code>rdb</code>文件，在生成<code>rdb</code>文件的过程中以及将<code>rdb</code>文件传给<code>从</code>并且<code>从</code>使用<code>rdb</code>文件恢复数据的过程中都没有新命令产生，那么<code>主从</code>的数据就可以保持一致。</p>\n<p>如果这期间产生了新的命令会不会导致<code>主从</code>数据不一致?</p>\n<p>根据<a href=\"https://redis.io/docs/management/replication/\">官方文档 How Redis replication works</a>中的介绍，我们可以知道期间产生的新命令会被<code>主</code>缓存起来，在<code>从</code>加载完<code>rdb</code>文件数据之后，<code>主</code>会将这期间缓存的命令发送给<code>从</code>，<code>从</code>在接受并执行完这些新命令后，就可以继续保持与<code>主</code>数据的一致性</p>\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221224202000.png\"></p>\n<h2 id=\"4-哨兵\"><a href=\"#4-哨兵\" class=\"headerlink\" title=\"4.哨兵\"></a>4.哨兵</h2><p><code>redis主从</code>固然可以提升服务的高可靠性，却依然需要人为去进行<code>监控</code>、<code>选主</code>和<code>通知</code>。看上去似乎不是很靠谱，因为我们不可能做到7 * 24小时盯着<code>redis</code>服务，在其出问题后手动进行故障转移并通知客户端<code>新主</code>的地址。</p>\n<p><code>redis</code>中我们可以通过<code>哨兵</code>机制来实现<code>监控</code>、<code>选主</code>、<code>通知</code>流程自动化，一来可以减轻开发人员压力；二来可以降低人为误操作率；三来可以提升故障恢复时效性。</p>\n<p>接下来会展示如何去搭建<code>哨兵</code>集群以及如何进行<code>选主</code>和<code>通知</code>客户端新主地址</p>\n<h3 id=\"4-1-生成sentinel配置文件\"><a href=\"#4-1-生成sentinel配置文件\" class=\"headerlink\" title=\"4.1 生成sentinel配置文件\"></a>4.1 生成sentinel配置文件</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">➜  redis-stable <span class=\"token function\">cat</span> sentinel.conf <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> <span class=\"token parameter variable\">-v</span> <span class=\"token string\">\"#\"</span> <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> <span class=\"token parameter variable\">-v</span> <span class=\"token string\">\"^$\"</span> <span class=\"token operator\">></span> ./conf/sentinel-26379.conf<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"4-2-拷贝sentinel配置文件\"><a href=\"#4-2-拷贝sentinel配置文件\" class=\"headerlink\" title=\"4.2 拷贝sentinel配置文件\"></a>4.2 拷贝sentinel配置文件</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">➜  redis-stable <span class=\"token function\">sed</span> <span class=\"token string\">'s/26379/26380/g'</span> conf/sentinel-26379.conf <span class=\"token operator\">></span> conf/sentinel-26380.conf\n➜  redis-stable <span class=\"token function\">sed</span> <span class=\"token string\">'s/26379/26381/g'</span> conf/sentinel-26379.conf <span class=\"token operator\">></span> conf/sentinel-26381.conf<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"4-3-启动sentinel\"><a href=\"#4-3-启动sentinel\" class=\"headerlink\" title=\"4.3 启动sentinel\"></a>4.3 启动sentinel</h3><h4 id=\"4-3-1-启动26379\"><a href=\"#4-3-1-启动26379\" class=\"headerlink\" title=\"4.3.1 启动26379\"></a>4.3.1 启动26379</h4><p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221223165800.png\"></p>\n<p>通过日志可以看到<code>sentinel</code>在启动的时候会生成一个唯一id，也就是<code>Sentinel Id</code>，并且还打印出了<code>redis主从</code>中<code>从</code>的相关信息，可是根据<code>sentinel</code>配置文件中的配置<code>sentinel monitor mymaster 127.0.0.1 6379 2</code>，<code>sentine</code>是不知道<code>从</code>的相关信息，那么它是从哪得到这些信息的呢？</p>\n<p>要想获得这些信息，<code>sentinel</code>只需要给监控的<code>主</code>发送<code>info</code>命令即可</p>\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221225152000.png\"></p>\n<h4 id=\"4-3-2-启动26380\"><a href=\"#4-3-2-启动26380\" class=\"headerlink\" title=\"4.3.2 启动26380\"></a>4.3.2 启动26380</h4><p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221223173300.png\"></p>\n<p>启动<code>sentinel26380</code>的时候通过日志可以看到其发现了<code>sentinel26379</code>的存在</p>\n<p>查看配置文件，可以看到配置文件中新增了<code>从</code>和其它<code>sentitnel</code>相关配置</p>\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221223173401.png\"></p>\n<h4 id=\"4-3-3-启动26381\"><a href=\"#4-3-3-启动26381\" class=\"headerlink\" title=\"4.3.3 启动26381\"></a>4.3.3 启动26381</h4><p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221223173700.png\"></p>\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221223173800.png\"></p>\n<p>同理<code>sentinel26381</code>启动的时候发现了<code>sentinel26379</code>和<code>sentinel26380</code>的存在并在配置文件中新增了相关配置</p>\n<h3 id=\"4-3-sentinel是如何发现彼此的存在？\"><a href=\"#4-3-sentinel是如何发现彼此的存在？\" class=\"headerlink\" title=\"4.3 sentinel是如何发现彼此的存在？\"></a>4.3 sentinel是如何发现彼此的存在？</h3><p>在<code>sentinel26381</code>启动完成后，<code>sentinel</code>集群也就搭建完成了，在搭建的过程中也留下了一个疑问：<code>sentinel</code>是如何发现彼此的存在？</p>\n<p>根据<a href=\"https://redis.io/docs/management/sentinel/#sentinels-and-replicas-auto-discovery\">官方文档High availability with Redis Sentinel中Sentinels and replicas auto discovery</a>的介绍，可以了解到<code>sentinel</code>是通过<code>Pub/Sub </code>机制来发现彼此的存在，当一个<code>sentinel</code>与<code>主</code>连接后，可以在<code>__sentinel__:hello</code>通道中发布其对应的<code>ip</code>、<code>port</code>和<code>runid</code>，同时订阅<code>__sentinel__:hello</code>通道，这样其它<code>sentinel</code>发布消息的时候就可以得知对应的<code>ip</code>和<code>port</code>。</p>\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221225154000.png\"></p>\n<h3 id=\"4-4-sentinel功能验证\"><a href=\"#4-4-sentinel功能验证\" class=\"headerlink\" title=\"4.4 sentinel功能验证\"></a>4.4 sentinel功能验证</h3><p><code>sentinel集群</code>搭建完成后，我们需要停掉<code>主</code>来验证其是否完成<code>监控</code>、<code>选主</code>和<code>通知</code>任务。</p>\n<p>首先停掉<code>主6379</code>，分别观察3个<code>sentinel</code>的变化</p>\n<h4 id=\"4-4-1-观察sentinel26379\"><a href=\"#4-4-1-观察sentinel26379\" class=\"headerlink\" title=\"4.4.1 观察sentinel26379\"></a>4.4.1 观察sentinel26379</h4><p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221223175100.png\"></p>\n<h4 id=\"4-4-2-观察sentinel26380\"><a href=\"#4-4-2-观察sentinel26380\" class=\"headerlink\" title=\"4.4.2 观察sentinel26380\"></a>4.4.2 观察sentinel26380</h4><p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221223175600.png\"></p>\n<h4 id=\"4-4-3-观察sentinel26381\"><a href=\"#4-4-3-观察sentinel26381\" class=\"headerlink\" title=\"4.4.3 观察sentinel26381\"></a>4.4.3 观察sentinel26381</h4><p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221223175701.png\"></p>\n<p>通过观察日志可以看到<code>主6379</code>下线后的一些变化：</p>\n<ul>\n<li>每个<code>sentinel</code>都监控到<code>主6379</code>下线，主观上认为其下线了(由于网络原因，可能存在误判)，对应日志中的<code>+sdown</code>部分</li>\n<li>当半数以上的<code>sentinel</code>认为<code>主6379</code>下线，则客观上认为其下线了(排除误判)，对应日志中的<code>+odown</code>部分</li>\n<li><code>sentinel</code>集群通过投票方式选出<code>sentinel26379</code>作为<code>leader</code>来执行<code>选主</code>操作</li>\n<li><code>sentinel26379</code>选择<code>redis6380</code>作为新的<code>主</code>，修改<code>slave</code>配置</li>\n</ul>\n<h4 id=\"4-4-5-重启redis6379\"><a href=\"#4-4-5-重启redis6379\" class=\"headerlink\" title=\"4.4.5 重启redis6379\"></a>4.4.5 重启redis6379</h4><p><code>sentinel</code>选出<code>新主</code>后，是否将<code>新主</code>地址通知到各个客户端。想要验证这个问题，只需要重启<code>redis6379</code>即可。</p>\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221225161500.png\"></p>\n<p><code>redis6379</code>启动后成功连接上新主<code>redis6380</code>并进行数据同步</p>\n<h3 id=\"4-5-从和重启后的旧主是如何知道新主的地址？\"><a href=\"#4-5-从和重启后的旧主是如何知道新主的地址？\" class=\"headerlink\" title=\"4.5 从和重启后的旧主是如何知道新主的地址？\"></a>4.5 从和重启后的旧主是如何知道新主的地址？</h3><p>通过上面的实战演示，可以得知，<code>主</code>宕机选出<code>新主</code>后，剩余的<code>从</code>会自动连接上<code>新主</code>并进行数据同步，<code>旧主</code>重启后也可以正常连接上<code>新主</code>并进行数据同步。对于<code>从</code>能连接上新主还可以理解，毕竟<code>redis主从切换</code>的过程中，<code>从</code>起码是运行状态，但是<code>旧主</code>在<code>redis主从切换</code>的过程中处于宕机状态，为什么在重启后还可以正常连接上<code>新主</code>？</p>\n<p>猜想应该是：在<code>redis主从切换</code>完成后，<code>sentinel leader</code>向<code>从</code>发送了<code>slaveof 新主host 新主port</code>命令，这样<code>从</code>就可以与<code>新主</code>连接并进行数据同步。针对<code>旧主</code>在其重启后，<code>sentinel</code>与之建立连接并发送<code>slaveof 新主host 新主port</code>命令，这样<code>旧主</code>也可以与<code>新主</code>连接并进行数据同步。</p>\n<h3 id=\"4-6-客户端应用是如何知道新主的地址？\"><a href=\"#4-6-客户端应用是如何知道新主的地址？\" class=\"headerlink\" title=\"4.6 客户端应用是如何知道新主的地址？\"></a>4.6 客户端应用是如何知道新主的地址？</h3><p>使用<code>springboot</code>集成<code>redis sentinel</code>，通常会在<code>application.yml</code>中添加如下配置：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">spring</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">redis</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">sentinel</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">master</span><span class=\"token punctuation\">:</span> mymaster\n      <span class=\"token key atrule\">nodes</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">-</span> 127.0.0.1<span class=\"token punctuation\">:</span><span class=\"token number\">26379</span>\n        <span class=\"token punctuation\">-</span> 127.0.0.1<span class=\"token punctuation\">:</span><span class=\"token number\">26380</span>\n        <span class=\"token punctuation\">-</span> 127.0.0.1<span class=\"token punctuation\">:</span><span class=\"token number\">26381</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>配置文件中仅仅只配置了<code>sentinel</code>节点信息，并没有配置<code>redis</code>相关地址信息，客户端是如何知道<code>redis</code>地址信息，当<code>redis</code>发送主从切换，客户端又是如何知道<code>新主</code>的地址信息？</p>\n<p>根据<a href=\"https://redis.io/docs/management/sentinel/#sentinels-and-replicas-auto-discovery\">官方文档High availability with Redis Sentinel中Obtaining the address of the current master</a>的介绍，客户端可以通过<code>SENTINEL get-master-addr-by-name mymaster</code>命令获取当前<code>主</code>的地址信息</p>\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/202212261640.png\"></p>\n<p>结合<code>客户端源码</code>分析</p>\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221226165400.png\"></p>\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221226165401.png\"></p>\n<p>我们可以得知客户端是通过向<code>sentinel</code>发送<code>get-master-addr-by-name mymaster</code>命令来获取<code>redis主</code>的连接地址</p>\n<h3 id=\"4-7-总结\"><a href=\"#4-7-总结\" class=\"headerlink\" title=\"4.7 总结\"></a>4.7 总结</h3><ul>\n<li>sentinel之间通过<code>redis</code>的<code>pub/sub</code>机制发现彼此的存在</li>\n<li><code>redis主从</code>切换后，<code>sentinel</code>向<code>从</code>和<code>旧主</code>发送<code>slaveof host port</code>命令来连接<code>新主</code></li>\n<li>客户端通过向<code>sentinel</code>发送<code>get-master-addr-by-name mymaster</code>命令来获取<code>redis</code>主的连接地址</li>\n</ul>\n<h2 id=\"5-集群\"><a href=\"#5-集群\" class=\"headerlink\" title=\"5.集群\"></a>5.集群</h2><p><code>redis主从</code>模式在大多数场景下都是比较适用，在面对需要持久化大量数据的场景下会变得比之前慢。慢的主要原因是：在进行<code>rdb</code>持久化会<code>fork</code>出一个子进程，<code>fork</code>操作会阻塞<code>主线程</code>并且阻塞时间与内存中的数据成正相关。因此，在面对大量数据需要持久化的场景时，可以考虑选择<code>redis-cluster</code>来进行应对。</p>\n<p>在使用集群时，需要考虑下面问题：</p>\n<ul>\n<li><code>key/value</code>在集群中如何分布</li>\n<li>想对某个<code>key/value</code>进行操作时，该连接那个节点</li>\n<li>集群节点数量发生变化，还用原来的地址操作<code>key/value</code>是否可行？</li>\n</ul>\n<p>为了弄明白这些问题，按照惯例，先来搭建<code>redis集群</code></p>\n<h3 id=\"5-1-集群搭建\"><a href=\"#5-1-集群搭建\" class=\"headerlink\" title=\"5.1 集群搭建\"></a>5.1 集群搭建</h3><h4 id=\"5-1-1-创建conf目录\"><a href=\"#5-1-1-创建conf目录\" class=\"headerlink\" title=\"5.1.1 创建conf目录\"></a>5.1.1 创建conf目录</h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">➜  redis-stable <span class=\"token function\">mkdir</span> conf<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h4 id=\"5-1-2-创建配置文件\"><a href=\"#5-1-2-创建配置文件\" class=\"headerlink\" title=\"5.1.2 创建配置文件\"></a>5.1.2 创建配置文件</h4><p>在<code>conf</code>目录下创建<code>redis-7001.conf</code>配置文件，内容如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">port <span class=\"token number\">7001</span>\ncluster-enabled <span class=\"token function\">yes</span>\ncluster-config-file nodes-7001.conf\ncluster-node-timeout <span class=\"token number\">5000</span>\nappendonly <span class=\"token function\">yes</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"5-1-3-拷贝集群配置文件\"><a href=\"#5-1-3-拷贝集群配置文件\" class=\"headerlink\" title=\"5.1.3 拷贝集群配置文件\"></a>5.1.3 拷贝集群配置文件</h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">➜  redis-stable <span class=\"token function\">sed</span> <span class=\"token string\">'s/7001/7002/g'</span> conf/redis-7001.conf <span class=\"token operator\">></span> conf/redis-7002.conf\n<span class=\"token function\">sed</span> <span class=\"token string\">'s/7001/7003/g'</span> conf/redis-7001.conf <span class=\"token operator\">></span> conf/redis-7003.conf\n<span class=\"token function\">sed</span> <span class=\"token string\">'s/7001/7004/g'</span> conf/redis-7001.conf <span class=\"token operator\">></span> conf/redis-7004.conf\n<span class=\"token function\">sed</span> <span class=\"token string\">'s/7001/7005/g'</span> conf/redis-7001.conf <span class=\"token operator\">></span> conf/redis-7005.conf\n<span class=\"token function\">sed</span> <span class=\"token string\">'s/7001/7006/g'</span> conf/redis-7001.conf <span class=\"token operator\">></span> conf/redis-7006.conf<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"5-1-4-分别启动redis服务\"><a href=\"#5-1-4-分别启动redis服务\" class=\"headerlink\" title=\"5.1.4 分别启动redis服务\"></a>5.1.4 分别启动redis服务</h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">➜  redis-stable redis-server conf/redis-7001.conf\n➜  redis-stable redis-server conf/redis-7002.conf\n➜  redis-stable redis-server conf/redis-7003.conf\n➜  redis-stable redis-server conf/redis-7004.conf\n➜  redis-stable redis-server conf/redis-7005.conf\n➜  redis-stable redis-server conf/redis-7006.conf<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"5-1-5-创建集群\"><a href=\"#5-1-5-创建集群\" class=\"headerlink\" title=\"5.1.5 创建集群\"></a>5.1.5 创建集群</h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">redis-cli <span class=\"token parameter variable\">--cluster</span> create <span class=\"token number\">127.0</span>.0.1:7001 <span class=\"token number\">127.0</span>.0.1:7002 <span class=\"token punctuation\">\\</span>\n<span class=\"token number\">127.0</span>.0.1:7003 <span class=\"token number\">127.0</span>.0.1:7004 <span class=\"token number\">127.0</span>.0.1:7005 <span class=\"token number\">127.0</span>.0.1:7006 <span class=\"token punctuation\">\\</span>\n--cluster-replicas <span class=\"token number\">1</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>输入完命令后，可以看到如下分配方案，针对分配方案输入<code>yes</code>即可</p>\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221227161600.png\"></p>\n<p>为了方便理解，可以看下图</p>\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221227104900.png\"></p>\n<p>到此，<code>redis集群</code>就搭建完成了</p>\n<h3 id=\"5-2-客户端连接集群\"><a href=\"#5-2-客户端连接集群\" class=\"headerlink\" title=\"5.2 客户端连接集群\"></a>5.2 客户端连接集群</h3><h4 id=\"5-2-1-缓存slot与实例映射关系\"><a href=\"#5-2-1-缓存slot与实例映射关系\" class=\"headerlink\" title=\"5.2.1 缓存slot与实例映射关系\"></a>5.2.1 缓存slot与实例映射关系</h4><p>搭建完<code>redis</code>集群后，可以通过<code>客户端</code>来连接<code>集群</code>，为了能更清晰了解<code>客户端</code>连接<code>集群</code>都做了些什么，这里选择使用<code>spring boot</code>应用作为<code>客户端</code>。通过源码调试，可以看到如下结果：</p>\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221227162500.png\"></p>\n<p>客户端应用在启动的时候会向<code>redis集群实例</code>发送<code>cluster slots</code>命令获取<code>slot</code>分配信息，然后在本地缓存<code>slot</code>与<code>redis实例</code>的映射关系</p>\n<h4 id=\"5-2-2-根据key计算对应slot\"><a href=\"#5-2-2-根据key计算对应slot\" class=\"headerlink\" title=\"5.2.2 根据key计算对应slot\"></a>5.2.2 根据key计算对应slot</h4><p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221227170500.png\"></p>\n<p>客户端在对<code>key/value</code>进行操作时，会对<code>key</code>进行<code>CRC</code>计算并和<code>cluster slot</code>数量进行<code>与</code>运算得到最终的<code>slot</code>值</p>\n<h4 id=\"5-2-3-根据slot获取实例\"><a href=\"#5-2-3-根据slot获取实例\" class=\"headerlink\" title=\"5.2.3 根据slot获取实例\"></a>5.2.3 根据slot获取实例</h4><p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221227171200.png\"></p>\n<p><code>5.2.1</code>中提到客户端会缓存<code>slot</code>与<code>实例</code>映射关系，<code>5.2.2</code>根据计算得到对应的<code>slot</code>，若想与<code>redis实例</code>交互，此时只需要从映射缓存中获取对应的<code>实例</code>既可</p>\n<h4 id=\"5-2-4-刷新slot与实例映射缓存关系\"><a href=\"#5-2-4-刷新slot与实例映射缓存关系\" class=\"headerlink\" title=\"5.2.4 刷新slot与实例映射缓存关系\"></a>5.2.4 刷新slot与实例映射缓存关系</h4><p><code>集群</code>环境往往会伴随着<code>实例</code>的上线与下线，不管是上线还是下线，都会使得<code>slot</code>重新分配，原本在某个实例上的<code>slot</code>会被分配到新的实例上，针对这种情况，客户端如果还是请求旧实例会发生什么？客户端又如何知道<code>slot</code>对应的实例发生了变化？</p>\n<p>为了演示该场景，会再运行两台<code>redis</code>实例，分别为:<code>redis7007</code>和<code>redis7008</code>，<code>redis</code>实例启动完成之后，通过<code>redis-cli --cluster add-node 127.0.0.1:7007 127.0.0.1:7001</code>命令将<code>redis7007</code>以<code>master</code>的方式加入到已存在的<code>集群</code>中，再通过<code>redis-cli --cluster add-node 127.0.0.1:7008 127.0.0.1:7000 --cluster-slave</code>命令将<code>redis7008</code>以<code>slave</code>的方式加入到已存在的<code>集群</code>中。</p>\n<p><code>redis</code>实例加入集群后，可以通过<code>redis-cli --cluster check 127.0.0.1:7001</code>命令来查看集群的当前情况</p>\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221228100100.png\"></p>\n<p>根据输出内容可以看到新加入的<code>redis7007</code>实例还没有分配<code>slot</code>，可以通过<code>redis-cli --cluster reshard 127.0.0.1:7001</code>命令来分配<code>slot</code>，分配成功之后原本在<code>redis7001</code>、<code>redis7002</code>、<code>redis7003</code>实例上的<code>slot</code>会移动到<code>redis7007</code>上。</p>\n<p>找一个原本在<code>redis7001</code>实例上后来被移动到<code>redis7007</code>实例上的key，执行<code>get</code>命令</p>\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221227180200.png\"></p>\n<p>执行完<code>get</code>命令后，可以看到服务端返回了错误，并告诉我们当前key已经移动到<code>redis7007</code>实例上，这是<code>redis-cli</code>客户端执行后的结果，应用客户端会如何处理呢？</p>\n<p><img src=\"https://wolf-heart.oss-cn-beijing.aliyuncs.com/blog/redis/20221228101600.png\"></p>\n<p>通过源码分析，可以得知当出现<code>JedisMovedDataException</code>异常后，应用客户端会重新发送<code>cluster slots</code>命令来刷新本地缓存</p>\n<h3 id=\"5-3-总结\"><a href=\"#5-3-总结\" class=\"headerlink\" title=\"5.3 总结\"></a>5.3 总结</h3><ul>\n<li>集群部署后，<code>16384</code>个<code>slot</code>会散落在各个<code>redis master</code>实例上</li>\n<li>客户端通过发送<code>cluster slots</code>命令在本地缓存<code>slot</code>与<code>redis</code>实例的映射关系</li>\n<li>对<code>key/value</code>进行操作时，<code>key</code>通过<code>CRC</code>计算并和<code>slot</code>数量 - 1进行<code>与</code>运算后得到对应<code>slot</code>，得到<code>slot</code>，又知道<code>slot</code>与<code>redis</code>实例的映射关系，就可以对<code>redis</code>实例进行访问</li>\n<li><code>slot</code>迁移后，客户端还用原来的实例执行命令，会出现异常，针对异常客户端会通过发送<code>cluster slots</code>命令来刷新本地<code>slot</code>与<code>redis</code>实例的映射关系</li>\n</ul>\n","text":"1.前言1.1 单机时代刚接触redis的时候，为了能快速学习和了解这门技术，我们通常会在自己的电脑上部署一个redis服务，以此来开启redis学习之路 1.2 主从时代随着对redis的进一步深入，很快就会发现这门技术在很多场景下都能得到应用，比如：并发场景下对共享资源的控制...","link":"","photos":[],"count_time":{"symbolsCount":"8.3k","symbolsTime":"8 mins."},"categories":[{"name":"redis","slug":"redis","count":3,"path":"api/categories/redis.json"}],"tags":[{"name":"redis","slug":"redis","count":2,"path":"api/tags/redis.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">1.前言</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E5%8D%95%E6%9C%BA%E6%97%B6%E4%BB%A3\"><span class=\"toc-text\">1.1 单机时代</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-%E4%B8%BB%E4%BB%8E%E6%97%B6%E4%BB%A3\"><span class=\"toc-text\">1.2 主从时代</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-%E5%93%A8%E5%85%B5%E6%97%B6%E4%BB%A3\"><span class=\"toc-text\">1.3 哨兵时代</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-%E9%9B%86%E7%BE%A4%E5%88%86%E7%89%87%E6%97%B6%E4%BB%A3\"><span class=\"toc-text\">1.4 集群分片时代</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-redis%E5%AE%89%E8%A3%85\"><span class=\"toc-text\">2.redis安装</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E5%8C%85\"><span class=\"toc-text\">2.1下载安装包</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2%E8%A7%A3%E5%8E%8B\"><span class=\"toc-text\">2.2解压</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E7%BC%96%E8%AF%91\"><span class=\"toc-text\">2.3 编译</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-%E5%90%AF%E5%8A%A8\"><span class=\"toc-text\">2.4 启动</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-5-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">2.5 客户端连接测试</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E4%B8%BB%E4%BB%8E\"><span class=\"toc-text\">3.主从</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-%E9%83%A8%E7%BD%B2%E5%9B%BE\"><span class=\"toc-text\">3.1 部署图</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-%E5%88%9B%E5%BB%BAconf%E7%9B%AE%E5%BD%95\"><span class=\"toc-text\">3.2 创建conf目录</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-%E7%94%9F%E6%88%90redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">3.3 生成redis配置文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-%E6%B7%BB%E5%8A%A0%E5%A4%8D%E5%88%B6%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">3.3 添加复制配置</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-%E6%8B%B7%E8%B4%9Dredis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">3.4 拷贝redis配置文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-5-%E5%90%AF%E5%8A%A8redis\"><span class=\"toc-text\">3.5 启动redis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-5-1-%E5%90%AF%E5%8A%A8%E4%B8%BB6379\"><span class=\"toc-text\">3.5.1 启动主6379</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-5-2-%E5%90%AF%E5%8A%A8%E4%BB%8E6380\"><span class=\"toc-text\">3.5.2 启动从6380</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-5-3-%E5%90%AF%E5%8A%A8%E4%BB%8E6381\"><span class=\"toc-text\">3.5.3 启动从6381</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-5-4-%E9%87%8D%E5%90%AF6381\"><span class=\"toc-text\">3.5.4 重启6381</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-6-%E4%B8%BB%E4%BB%8E%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F\"><span class=\"toc-text\">3.6 主从如何保证数据一致性？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%93%A8%E5%85%B5\"><span class=\"toc-text\">4.哨兵</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-%E7%94%9F%E6%88%90sentinel%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">4.1 生成sentinel配置文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-%E6%8B%B7%E8%B4%9Dsentinel%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">4.2 拷贝sentinel配置文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-%E5%90%AF%E5%8A%A8sentinel\"><span class=\"toc-text\">4.3 启动sentinel</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-3-1-%E5%90%AF%E5%8A%A826379\"><span class=\"toc-text\">4.3.1 启动26379</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-3-2-%E5%90%AF%E5%8A%A826380\"><span class=\"toc-text\">4.3.2 启动26380</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-3-3-%E5%90%AF%E5%8A%A826381\"><span class=\"toc-text\">4.3.3 启动26381</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-sentinel%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0%E5%BD%BC%E6%AD%A4%E7%9A%84%E5%AD%98%E5%9C%A8%EF%BC%9F\"><span class=\"toc-text\">4.3 sentinel是如何发现彼此的存在？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-sentinel%E5%8A%9F%E8%83%BD%E9%AA%8C%E8%AF%81\"><span class=\"toc-text\">4.4 sentinel功能验证</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-4-1-%E8%A7%82%E5%AF%9Fsentinel26379\"><span class=\"toc-text\">4.4.1 观察sentinel26379</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-4-2-%E8%A7%82%E5%AF%9Fsentinel26380\"><span class=\"toc-text\">4.4.2 观察sentinel26380</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-4-3-%E8%A7%82%E5%AF%9Fsentinel26381\"><span class=\"toc-text\">4.4.3 观察sentinel26381</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-4-5-%E9%87%8D%E5%90%AFredis6379\"><span class=\"toc-text\">4.4.5 重启redis6379</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-5-%E4%BB%8E%E5%92%8C%E9%87%8D%E5%90%AF%E5%90%8E%E7%9A%84%E6%97%A7%E4%B8%BB%E6%98%AF%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E6%96%B0%E4%B8%BB%E7%9A%84%E5%9C%B0%E5%9D%80%EF%BC%9F\"><span class=\"toc-text\">4.5 从和重启后的旧主是如何知道新主的地址？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-6-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BA%94%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E6%96%B0%E4%B8%BB%E7%9A%84%E5%9C%B0%E5%9D%80%EF%BC%9F\"><span class=\"toc-text\">4.6 客户端应用是如何知道新主的地址？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-7-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">4.7 总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E9%9B%86%E7%BE%A4\"><span class=\"toc-text\">5.集群</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA\"><span class=\"toc-text\">5.1 集群搭建</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-1-1-%E5%88%9B%E5%BB%BAconf%E7%9B%AE%E5%BD%95\"><span class=\"toc-text\">5.1.1 创建conf目录</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-1-2-%E5%88%9B%E5%BB%BA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">5.1.2 创建配置文件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-1-3-%E6%8B%B7%E8%B4%9D%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">5.1.3 拷贝集群配置文件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-1-4-%E5%88%86%E5%88%AB%E5%90%AF%E5%8A%A8redis%E6%9C%8D%E5%8A%A1\"><span class=\"toc-text\">5.1.4 分别启动redis服务</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-1-5-%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4\"><span class=\"toc-text\">5.1.5 创建集群</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E9%9B%86%E7%BE%A4\"><span class=\"toc-text\">5.2 客户端连接集群</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-2-1-%E7%BC%93%E5%AD%98slot%E4%B8%8E%E5%AE%9E%E4%BE%8B%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">5.2.1 缓存slot与实例映射关系</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-2-2-%E6%A0%B9%E6%8D%AEkey%E8%AE%A1%E7%AE%97%E5%AF%B9%E5%BA%94slot\"><span class=\"toc-text\">5.2.2 根据key计算对应slot</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-2-3-%E6%A0%B9%E6%8D%AEslot%E8%8E%B7%E5%8F%96%E5%AE%9E%E4%BE%8B\"><span class=\"toc-text\">5.2.3 根据slot获取实例</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-2-4-%E5%88%B7%E6%96%B0slot%E4%B8%8E%E5%AE%9E%E4%BE%8B%E6%98%A0%E5%B0%84%E7%BC%93%E5%AD%98%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">5.2.4 刷新slot与实例映射缓存关系</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-3-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">5.3 总结</span></a></li></ol></li></ol>","author":{"name":"黑白搬砖工","slug":"blog-author","avatar":"https://wolf-heart.oss-cn-beijing.aliyuncs.com/lg_22641_1606122876_5fbb7d7c432a1.jpeg","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/a601942905git","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/483440845930343","customs":{}}},"mapped":true,"prev_post":{"title":"动态伸缩你的服务","uid":"a74d032dc9bf8ca9d012adc342b4fd84","slug":"动态伸缩你的服务","date":"2022-12-10T13:57:00.000Z","updated":"2022-12-10T14:01:06.650Z","comments":true,"path":"api/articles/动态伸缩你的服务.json","keywords":null,"cover":[],"text":"1.前言如你所知，服务的常规部署方式如下： 对外暴露的服务都会在前面部署nginx用于提供反向代理和负载均衡能力 下面会快速部署一套类似的服务，分析其存在的问题并给出相应解决方案 2.应用相关2.1 启动服务使用boot-cloud-openfeign-provider启动3个服...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"微服务","slug":"微服务","count":3,"path":"api/categories/微服务.json"}],"tags":[{"name":"consul","slug":"consul","count":1,"path":"api/tags/consul.json"},{"name":"nginx","slug":"nginx","count":1,"path":"api/tags/nginx.json"},{"name":"consul-template","slug":"consul-template","count":1,"path":"api/tags/consul-template.json"}],"author":{"name":"黑白搬砖工","slug":"blog-author","avatar":"https://wolf-heart.oss-cn-beijing.aliyuncs.com/lg_22641_1606122876_5fbb7d7c432a1.jpeg","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/a601942905git","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/483440845930343","customs":{}}},"feature":true},"next_post":{"title":"一文读懂Redis持久化机制","uid":"077c9e1306e9e7f4038efb1171146e9a","slug":"一文读懂Redis持久化机制","date":"2022-12-18T07:32:00.000Z","updated":"2023-03-05T12:46:25.578Z","comments":true,"path":"api/articles/一文读懂Redis持久化机制.json","keywords":null,"cover":[],"text":"1.前言redis作为内存数据库，最常见的使用场景就是当缓存用。浏览器访问后端应用，后端应用先访问redis，如果redis中有数据，直接返回；否则就去查询数据库。 如你所知，redis作为内存数据库，数据存放在内存中，如果宕机，会导致数据全部丢失。数据丢失，来自浏览器的所有请求...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"redis","slug":"redis","count":3,"path":"api/categories/redis.json"}],"tags":[{"name":"redis","slug":"redis","count":2,"path":"api/tags/redis.json"}],"author":{"name":"黑白搬砖工","slug":"blog-author","avatar":"https://wolf-heart.oss-cn-beijing.aliyuncs.com/lg_22641_1606122876_5fbb7d7c432a1.jpeg","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/a601942905git","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"https://juejin.cn/user/483440845930343","customs":{}}}}}